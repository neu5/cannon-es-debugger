{"mappings":";;AAeA,2BAA2B;IACzB,KAAK,CAAC,EAAE,MAAM,GAAG,MAAM,GAAG,MAAM,CAAA;IAChC,KAAK,CAAC,EAAE,MAAM,CAAA;IACd,MAAM,CAAC,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,KAAK,IAAI,CAAA;IACvD,QAAQ,CAAC,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,KAAK,IAAI,CAAA;CAC1D,CAAA;AAED,uCACE,KAAK,EAAE,KAAK,EACZ,KAAK,EAAE,KAAK,EACZ,EAAE,KAAgB,EAAE,KAAS,EAAE,MAAM,EAAE,QAAQ,EAAE,GAAE,YAAiB;kBAmMjD,IAAI;EA0CxB","sources":["src/src/cannon-es-debugger.ts","src/cannon-es-debugger.ts"],"sourcesContent":[null,"import {\n  Vec3 as CannonVector3,\n  Sphere,\n  Box,\n  ConvexPolyhedron,\n  Trimesh,\n  Heightfield,\n  Shape,\n  Quaternion as CannonQuaternion,\n  Cylinder,\n} from 'cannon-es'\nimport { AbstractMesh, Color3, Mesh, MeshBuilder, Scene, StandardMaterial, Vector3, Quaternion } from '@babylonjs/core'\nimport type { Body, World } from 'cannon-es'\n\ntype ComplexShape = Shape & { geometryId?: number }\nexport type DebugOptions = {\n  color?: string | number | Color3\n  scale?: number\n  onInit?: (body: Body, mesh: Mesh, shape: Shape) => void\n  onUpdate?: (body: Body, mesh: Mesh, shape: Shape) => void\n}\n\nexport default function CannonDebugger(\n  scene: Scene,\n  world: World,\n  { color = 0x00ff00, scale = 1, onInit, onUpdate }: DebugOptions = {}\n) {\n  const _meshes: Mesh[] = []\n  // const _material = new MeshBasicMaterial({ color: color ?? 0x00ff00, wireframe: true })\n  const _material = new StandardMaterial('myMaterial', scene)\n  _material.diffuseColor = new Color3(0, 1, 0)\n  _material.wireframe = true\n  const _tempVec0 = new CannonVector3()\n  const _tempVec1 = new CannonVector3()\n  const _tempVec2 = new CannonVector3()\n  const _tempQuat0 = new CannonQuaternion()\n\n  //   function createConvexPolyhedronGeometry(shape: ConvexPolyhedron): BufferGeometry {\n  //     const geometry = new BufferGeometry()\n  //     // Add vertices\n  //     const positions = []\n  //     for (let i = 0; i < shape.vertices.length; i++) {\n  //       const vertex = shape.vertices[i]\n  //       positions.push(vertex.x, vertex.y, vertex.z)\n  //     }\n  //     geometry.setAttribute('position', new Float32BufferAttribute(positions, 3))\n  //     // Add faces\n  //     const indices = []\n  //     for (let i = 0; i < shape.faces.length; i++) {\n  //       const face = shape.faces[i]\n  //       const a = face[0]\n  //       for (let j = 1; j < face.length - 1; j++) {\n  //         const b = face[j]\n  //         const c = face[j + 1]\n  //         indices.push(a, b, c)\n  //       }\n  //     }\n  //     geometry.setIndex(indices)\n  //     geometry.computeBoundingSphere()\n  //     geometry.computeVertexNormals()\n  //     return geometry\n  //   }\n  //   function createTrimeshGeometry(shape: Trimesh): BufferGeometry {\n  //     const geometry = new BufferGeometry()\n  //     const positions = []\n  //     const v0 = _tempVec0\n  //     const v1 = _tempVec1\n  //     const v2 = _tempVec2\n  //     for (let i = 0; i < shape.indices.length / 3; i++) {\n  //       shape.getTriangleVertices(i, v0, v1, v2)\n  //       positions.push(v0.x, v0.y, v0.z)\n  //       positions.push(v1.x, v1.y, v1.z)\n  //       positions.push(v2.x, v2.y, v2.z)\n  //     }\n  //     geometry.setAttribute('position', new Float32BufferAttribute(positions, 3))\n  //     geometry.computeBoundingSphere()\n  //     geometry.computeVertexNormals()\n  //     return geometry\n  //   }\n  //   function createHeightfieldGeometry(shape: Heightfield): BufferGeometry {\n  //     const geometry = new BufferGeometry()\n  //     const s = shape.elementSize || 1 // assumes square heightfield, else i*x, j*y\n  //     const positions = shape.data.flatMap((row, i) => row.flatMap((z, j) => [i * s, j * s, z]))\n  //     const indices = []\n  //     for (let xi = 0; xi < shape.data.length - 1; xi++) {\n  //       for (let yi = 0; yi < shape.data[xi].length - 1; yi++) {\n  //         const stride = shape.data[xi].length\n  //         const index = xi * stride + yi\n  //         indices.push(index + 1, index + stride, index + stride + 1)\n  //         indices.push(index + stride, index + 1, index)\n  //       }\n  //     }\n  //     geometry.setIndex(indices)\n  //     geometry.setAttribute('position', new Float32BufferAttribute(positions, 3))\n  //     geometry.computeBoundingSphere()\n  //     geometry.computeVertexNormals()\n  //     return geometry\n  //   }\n  function createMesh(shape: Shape): AbstractMesh {\n    let mesh\n    const { SPHERE, BOX, PLANE, CYLINDER, CONVEXPOLYHEDRON, TRIMESH, HEIGHTFIELD } = Shape.types\n\n    switch (shape.type) {\n      case SPHERE: {\n        mesh = MeshBuilder.CreateSphere('sphere', { segments: 16 }, scene)\n        mesh.rotationQuaternion = mesh.rotationQuaternion || new Quaternion()\n        break\n      }\n      case PLANE: {\n        mesh = MeshBuilder.CreatePlane('plane', { width: 10, height: 10 }, scene)\n        mesh.rotation = new Vector3(Math.PI / 2, 0, 0)\n        break\n      }\n      case BOX: {\n        mesh = MeshBuilder.CreateBox('box', {}, scene)\n        mesh.rotationQuaternion = mesh.rotationQuaternion || new Quaternion()\n        break\n      }\n      case CYLINDER: {\n        const { height, radiusBottom, radiusTop } = shape\n        mesh = MeshBuilder.CreateCylinder(\n          'cylinder',\n          { diameterTop: radiusTop * 2, diameterBottom: radiusBottom * 2, height },\n          scene\n        )\n        mesh.rotationQuaternion = mesh.rotationQuaternion || new Quaternion()\n        break\n      }\n      //   case CONVEXPOLYHEDRON: {\n      //     const geometry = createConvexPolyhedronGeometry(shape as ConvexPolyhedron)\n      //     mesh = new Mesh(geometry, _material)\n      //     ;(shape as ComplexShape).geometryId = geometry.id\n      //     break\n      //   }\n      //   case TRIMESH: {\n      //     const geometry = createTrimeshGeometry(shape as Trimesh)\n      //     mesh = new Mesh(geometry, _material)\n      //     ;(shape as ComplexShape).geometryId = geometry.id\n      //     break\n      //   }\n      //   case HEIGHTFIELD: {\n      //     const geometry = createHeightfieldGeometry(shape as Heightfield)\n      //     mesh = new Mesh(geometry, _material)\n      //     ;(shape as ComplexShape).geometryId = geometry.id\n      //     break\n      //   }\n    }\n\n    mesh.material = _material\n    scene.addMesh(mesh)\n    return mesh\n  }\n\n  function scaleMesh(mesh: Mesh, shape: Shape): void {\n    const { SPHERE, BOX, PLANE, CYLINDER, CONVEXPOLYHEDRON, TRIMESH, HEIGHTFIELD } = Shape.types\n    switch (shape.type) {\n      case SPHERE: {\n        const { radius } = shape as Sphere\n        mesh.scalingDeterminant = radius * scale * 2\n        break\n      }\n      case BOX: {\n        const size = new Vector3(\n          shape.halfExtents.x * scale * 2,\n          shape.halfExtents.y * scale * 2,\n          shape.halfExtents.z * scale * 2\n        )\n        mesh.scaling = size\n        break\n      }\n      case PLANE: {\n        break\n      }\n      case CYLINDER: {\n        break\n      }\n      // case CONVEXPOLYHEDRON: {\n      //   mesh.scale.set(1 * scale, 1 * scale, 1 * scale)\n      //   break\n      // }\n      // case TRIMESH: {\n      //   mesh.scale.copy((shape as Trimesh).scale as unknown as Vector3).multiplyScalar(scale)\n      //   break\n      // }\n      // case HEIGHTFIELD: {\n      //   mesh.scale.set(1 * scale, 1 * scale, 1 * scale)\n      //   break\n      // }\n    }\n  }\n\n  function typeMatch(mesh: AbstractMesh, shape: Shape | ComplexShape): boolean {\n    if (!mesh) return false\n    // const { geometry } = mesh\n\n    return (\n      shape.type === Shape.types.SPHERE ||\n      shape.type === Shape.types.PLANE ||\n      shape.type === Shape.types.BOX ||\n      shape.type === Shape.types.CYLINDER\n    )\n    // geometry instanceof SphereGeometry && shape.type === Shape.types.SPHERE ||\n    // (geometry instanceof BoxGeometry && shape.type === Shape.types.BOX) ||\n    // (geometry instanceof PlaneGeometry && shape.type === Shape.types.PLANE) ||\n    // (geometry.id === (shape as ComplexShape).geometryId && shape.type === Shape.types.CYLINDER) ||\n    // (geometry.id === (shape as ComplexShape).geometryId && shape.type === Shape.types.CONVEXPOLYHEDRON) ||\n    // (geometry.id === (shape as ComplexShape).geometryId && shape.type === Shape.types.TRIMESH) ||\n    // (geometry.id === (shape as ComplexShape).geometryId && shape.type === Shape.types.HEIGHTFIELD)\n  }\n  function updateMesh(index: number, shape: Shape | ComplexShape): boolean {\n    let mesh = _meshes[index]\n    let didCreateNewMesh = false\n    if (!typeMatch(mesh, shape)) {\n      if (mesh) scene.removeMesh(mesh)\n      _meshes[index] = mesh = createMesh(shape)\n      didCreateNewMesh = true\n    }\n    scaleMesh(mesh, shape)\n    return didCreateNewMesh\n  }\n  function update(): void {\n    const meshes = _meshes\n    const shapeWorldPosition = _tempVec0\n    const shapeWorldQuaternion = _tempQuat0\n    let meshIndex = 0\n    for (const body of world.bodies) {\n      for (let i = 0; i !== body.shapes.length; i++) {\n        const shape = body.shapes[i]\n        const didCreateNewMesh = updateMesh(meshIndex, shape)\n        const mesh = meshes[meshIndex]\n        if (mesh) {\n          // Get world position\n          body.quaternion.vmult(body.shapeOffsets[i], shapeWorldPosition)\n          body.position.vadd(shapeWorldPosition, shapeWorldPosition)\n          // Get world quaternion\n          body.quaternion.mult(body.shapeOrientations[i], shapeWorldQuaternion)\n          // Copy to meshes\n          mesh.position.set(shapeWorldPosition.x, shapeWorldPosition.y, shapeWorldPosition.z)\n\n          if (mesh.rotationQuaternion) {\n            mesh.rotationQuaternion.set(\n              shapeWorldQuaternion.x,\n              shapeWorldQuaternion.y,\n              shapeWorldQuaternion.z,\n              shapeWorldQuaternion.w\n            )\n          }\n\n          if (didCreateNewMesh && onInit instanceof Function) onInit(body, mesh, shape)\n          if (!didCreateNewMesh && onUpdate instanceof Function) onUpdate(body, mesh, shape)\n        }\n        meshIndex++\n      }\n    }\n    for (let i = meshIndex; i < meshes.length; i++) {\n      const mesh = meshes[i]\n      if (mesh) scene.removeMesh(mesh)\n    }\n    meshes.length = meshIndex\n  }\n\n  return { update }\n}\n"],"names":[],"version":3,"file":"cannon-es-debugger.d.ts.map","sourceRoot":"../"}