{"mappings":"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","sources":["src/cannon-es-debugger.ts"],"sourcesContent":["import {\n  Vec3 as CannonVector3,\n  Sphere,\n  Box,\n  ConvexPolyhedron,\n  Trimesh,\n  Heightfield,\n  Shape,\n  Quaternion as CannonQuaternion,\n  Cylinder,\n} from 'cannon-es'\nimport { AbstractMesh, Color3, Mesh, MeshBuilder, Scene, StandardMaterial, Vector3, Quaternion } from '@babylonjs/core'\nimport type { Body, World } from 'cannon-es'\n\ntype ComplexShape = Shape & { geometryId?: number }\nexport type DebugOptions = {\n  color?: string | number | Color3\n  scale?: number\n  onInit?: (body: Body, mesh: Mesh, shape: Shape) => void\n  onUpdate?: (body: Body, mesh: Mesh, shape: Shape) => void\n}\n\nexport default function CannonDebugger(\n  scene: Scene,\n  world: World,\n  { color = 0x00ff00, scale = 1, onInit, onUpdate }: DebugOptions = {}\n) {\n  const _meshes: Mesh[] = []\n  // const _material = new MeshBasicMaterial({ color: color ?? 0x00ff00, wireframe: true })\n  const _material = new StandardMaterial('myMaterial', scene)\n  _material.diffuseColor = new Color3(0, 1, 0)\n  _material.wireframe = true\n  const _tempVec0 = new CannonVector3()\n  const _tempVec1 = new CannonVector3()\n  const _tempVec2 = new CannonVector3()\n  const _tempQuat0 = new CannonQuaternion()\n\n  //   function createConvexPolyhedronGeometry(shape: ConvexPolyhedron): BufferGeometry {\n  //     const geometry = new BufferGeometry()\n  //     // Add vertices\n  //     const positions = []\n  //     for (let i = 0; i < shape.vertices.length; i++) {\n  //       const vertex = shape.vertices[i]\n  //       positions.push(vertex.x, vertex.y, vertex.z)\n  //     }\n  //     geometry.setAttribute('position', new Float32BufferAttribute(positions, 3))\n  //     // Add faces\n  //     const indices = []\n  //     for (let i = 0; i < shape.faces.length; i++) {\n  //       const face = shape.faces[i]\n  //       const a = face[0]\n  //       for (let j = 1; j < face.length - 1; j++) {\n  //         const b = face[j]\n  //         const c = face[j + 1]\n  //         indices.push(a, b, c)\n  //       }\n  //     }\n  //     geometry.setIndex(indices)\n  //     geometry.computeBoundingSphere()\n  //     geometry.computeVertexNormals()\n  //     return geometry\n  //   }\n  //   function createTrimeshGeometry(shape: Trimesh): BufferGeometry {\n  //     const geometry = new BufferGeometry()\n  //     const positions = []\n  //     const v0 = _tempVec0\n  //     const v1 = _tempVec1\n  //     const v2 = _tempVec2\n  //     for (let i = 0; i < shape.indices.length / 3; i++) {\n  //       shape.getTriangleVertices(i, v0, v1, v2)\n  //       positions.push(v0.x, v0.y, v0.z)\n  //       positions.push(v1.x, v1.y, v1.z)\n  //       positions.push(v2.x, v2.y, v2.z)\n  //     }\n  //     geometry.setAttribute('position', new Float32BufferAttribute(positions, 3))\n  //     geometry.computeBoundingSphere()\n  //     geometry.computeVertexNormals()\n  //     return geometry\n  //   }\n  //   function createHeightfieldGeometry(shape: Heightfield): BufferGeometry {\n  //     const geometry = new BufferGeometry()\n  //     const s = shape.elementSize || 1 // assumes square heightfield, else i*x, j*y\n  //     const positions = shape.data.flatMap((row, i) => row.flatMap((z, j) => [i * s, j * s, z]))\n  //     const indices = []\n  //     for (let xi = 0; xi < shape.data.length - 1; xi++) {\n  //       for (let yi = 0; yi < shape.data[xi].length - 1; yi++) {\n  //         const stride = shape.data[xi].length\n  //         const index = xi * stride + yi\n  //         indices.push(index + 1, index + stride, index + stride + 1)\n  //         indices.push(index + stride, index + 1, index)\n  //       }\n  //     }\n  //     geometry.setIndex(indices)\n  //     geometry.setAttribute('position', new Float32BufferAttribute(positions, 3))\n  //     geometry.computeBoundingSphere()\n  //     geometry.computeVertexNormals()\n  //     return geometry\n  //   }\n  function createMesh(shape: Shape): AbstractMesh {\n    let mesh\n    const { SPHERE, BOX, PLANE, CYLINDER, CONVEXPOLYHEDRON, TRIMESH, HEIGHTFIELD } = Shape.types\n\n    switch (shape.type) {\n      case SPHERE: {\n        mesh = MeshBuilder.CreateSphere('sphere', { segments: 16 }, scene)\n        mesh.rotationQuaternion = mesh.rotationQuaternion || new Quaternion()\n        break\n      }\n      case PLANE: {\n        mesh = MeshBuilder.CreatePlane('plane', { width: 10, height: 10 }, scene)\n        mesh.rotation = new Vector3(Math.PI / 2, 0, 0)\n        break\n      }\n      case BOX: {\n        mesh = MeshBuilder.CreateBox('box', {}, scene)\n        mesh.rotationQuaternion = mesh.rotationQuaternion || new Quaternion()\n        break\n      }\n      case CYLINDER: {\n        const { height, radiusBottom, radiusTop } = shape\n        mesh = MeshBuilder.CreateCylinder(\n          'cylinder',\n          { diameterTop: radiusTop * 2, diameterBottom: radiusBottom * 2, height },\n          scene\n        )\n        mesh.rotationQuaternion = mesh.rotationQuaternion || new Quaternion()\n        break\n      }\n      //   case CONVEXPOLYHEDRON: {\n      //     const geometry = createConvexPolyhedronGeometry(shape as ConvexPolyhedron)\n      //     mesh = new Mesh(geometry, _material)\n      //     ;(shape as ComplexShape).geometryId = geometry.id\n      //     break\n      //   }\n      //   case TRIMESH: {\n      //     const geometry = createTrimeshGeometry(shape as Trimesh)\n      //     mesh = new Mesh(geometry, _material)\n      //     ;(shape as ComplexShape).geometryId = geometry.id\n      //     break\n      //   }\n      //   case HEIGHTFIELD: {\n      //     const geometry = createHeightfieldGeometry(shape as Heightfield)\n      //     mesh = new Mesh(geometry, _material)\n      //     ;(shape as ComplexShape).geometryId = geometry.id\n      //     break\n      //   }\n    }\n\n    mesh.material = _material\n    scene.addMesh(mesh)\n    return mesh\n  }\n\n  function scaleMesh(mesh: Mesh, shape: Shape): void {\n    const { SPHERE, BOX, PLANE, CYLINDER, CONVEXPOLYHEDRON, TRIMESH, HEIGHTFIELD } = Shape.types\n    switch (shape.type) {\n      case SPHERE: {\n        const { radius } = shape as Sphere\n        mesh.scalingDeterminant = radius * scale * 2\n        break\n      }\n      case BOX: {\n        const size = new Vector3(\n          shape.halfExtents.x * scale * 2,\n          shape.halfExtents.y * scale * 2,\n          shape.halfExtents.z * scale * 2\n        )\n        mesh.scaling = size\n        break\n      }\n      case PLANE: {\n        break\n      }\n      case CYLINDER: {\n        break\n      }\n      // case CONVEXPOLYHEDRON: {\n      //   mesh.scale.set(1 * scale, 1 * scale, 1 * scale)\n      //   break\n      // }\n      // case TRIMESH: {\n      //   mesh.scale.copy((shape as Trimesh).scale as unknown as Vector3).multiplyScalar(scale)\n      //   break\n      // }\n      // case HEIGHTFIELD: {\n      //   mesh.scale.set(1 * scale, 1 * scale, 1 * scale)\n      //   break\n      // }\n    }\n  }\n\n  function typeMatch(mesh: AbstractMesh, shape: Shape | ComplexShape): boolean {\n    if (!mesh) return false\n    // const { geometry } = mesh\n\n    return (\n      shape.type === Shape.types.SPHERE ||\n      shape.type === Shape.types.PLANE ||\n      shape.type === Shape.types.BOX ||\n      shape.type === Shape.types.CYLINDER\n    )\n    // geometry instanceof SphereGeometry && shape.type === Shape.types.SPHERE ||\n    // (geometry instanceof BoxGeometry && shape.type === Shape.types.BOX) ||\n    // (geometry instanceof PlaneGeometry && shape.type === Shape.types.PLANE) ||\n    // (geometry.id === (shape as ComplexShape).geometryId && shape.type === Shape.types.CYLINDER) ||\n    // (geometry.id === (shape as ComplexShape).geometryId && shape.type === Shape.types.CONVEXPOLYHEDRON) ||\n    // (geometry.id === (shape as ComplexShape).geometryId && shape.type === Shape.types.TRIMESH) ||\n    // (geometry.id === (shape as ComplexShape).geometryId && shape.type === Shape.types.HEIGHTFIELD)\n  }\n  function updateMesh(index: number, shape: Shape | ComplexShape): boolean {\n    let mesh = _meshes[index]\n    let didCreateNewMesh = false\n    if (!typeMatch(mesh, shape)) {\n      if (mesh) scene.removeMesh(mesh)\n      _meshes[index] = mesh = createMesh(shape)\n      didCreateNewMesh = true\n    }\n    scaleMesh(mesh, shape)\n    return didCreateNewMesh\n  }\n  function update(): void {\n    const meshes = _meshes\n    const shapeWorldPosition = _tempVec0\n    const shapeWorldQuaternion = _tempQuat0\n    let meshIndex = 0\n    for (const body of world.bodies) {\n      for (let i = 0; i !== body.shapes.length; i++) {\n        const shape = body.shapes[i]\n        const didCreateNewMesh = updateMesh(meshIndex, shape)\n        const mesh = meshes[meshIndex]\n        if (mesh) {\n          // Get world position\n          body.quaternion.vmult(body.shapeOffsets[i], shapeWorldPosition)\n          body.position.vadd(shapeWorldPosition, shapeWorldPosition)\n          // Get world quaternion\n          body.quaternion.mult(body.shapeOrientations[i], shapeWorldQuaternion)\n          // Copy to meshes\n          mesh.position.set(shapeWorldPosition.x, shapeWorldPosition.y, shapeWorldPosition.z)\n\n          if (mesh.rotationQuaternion) {\n            mesh.rotationQuaternion.set(\n              shapeWorldQuaternion.x,\n              shapeWorldQuaternion.y,\n              shapeWorldQuaternion.z,\n              shapeWorldQuaternion.w\n            )\n          }\n\n          if (didCreateNewMesh && onInit instanceof Function) onInit(body, mesh, shape)\n          if (!didCreateNewMesh && onUpdate instanceof Function) onUpdate(body, mesh, shape)\n        }\n        meshIndex++\n      }\n    }\n    for (let i = meshIndex; i < meshes.length; i++) {\n      const mesh = meshes[i]\n      if (mesh) scene.removeMesh(mesh)\n    }\n    meshes.length = meshIndex\n  }\n\n  return { update }\n}\n"],"names":[],"version":3,"file":"cannon-es-debugger.js.map","sourceRoot":"../"}